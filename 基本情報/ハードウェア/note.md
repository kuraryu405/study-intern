# ハードウェア
## 代表的な5台装置

1. **レジスタ**
   - データを一時的に記憶する装置。
   - CPU内部で計算途中の値やアドレスなどを保持する。
   - 高速に読み書きできる。

2. **ALU（算術論理演算装置）**
   - Arithmetic Logic Unitの略。
   - 加算・減算などの算術演算や、AND・ORなどの論理演算を行う。
   - CPUの中核的な演算装置。

3. **制御装置**
   - プログラムの命令を解釈し、各装置に指示を出す。
   - 命令の取り出し、解読、実行の流れを制御する。

4. **主記憶装置（メインメモリ）**
   - プログラムやデータを一時的に保存する装置。
   - CPUが直接アクセスできる記憶領域（RAMなど）。

5. **入出力装置（I/O装置）**
   - コンピュータと外部（人や他の機器）とのデータのやり取りを行う装置。
   - 例：キーボード、ディスプレイ、プリンタ、USBメモリなど。



***

# 並列処理の分類

コンピュータの並列処理（パラレルプロセッシング）は、命令とデータの流れによって以下の4タイプに分けられるよ。

| 略称 | 名前（日本語）                | 名前（英語）                                       | 説明                                             |
|:----:|:--------------------------|:--------------------------------------------------|:------------------------------------------------|
| SISD | 単一命令・単一データ流      | Single Instruction Stream Single Data Stream      | 一般的な「順次処理」のCPU。1つの命令で1つのデータを処理。        |
| SIMD | 単一命令・複数データ流      | Single Instruction Stream Multi Data Stream       | 1つの命令で複数のデータを同時処理（画像処理やGPU等）。            |
| MISD | 複数命令・単一データ流      | Multi Instruction Stream Single Data Stream       | 複数の命令を1つのデータに適用。実際はほとんど使われない。         |
| MIMD | 複数命令・複数データ流      | Multi Instruction Stream Multi Data Stream        | 複数の命令で複数のデータを同時並行に処理（サーバ、マルチコアCPU等）。 |

***

## イメージ図（例）

- **SISD**：ふつうの1人作業
- **SIMD**：先生が同時にみんなに「同じ作業」を指示して、みんなで別のデータを処理
- **MISD**：みんなが同じデータをいろんなやり方で料理する
- **MIMD**：みんながバラバラの作業をバラバラのデータでやってる（複雑なチーム戦！）

***

### 補足
- 実際に使われているのは主にSISD、SIMD、MIMD
- SIMD：GPU（画像処理やAI計算で大活躍！）
- MIMD：サーバやデスクトップPCのマルチコアCPU

***

***

# 並列処理方式のグラフィカル解説

## SISD（Single Instruction Single Data）

```
[命令]→[CPU]→[データ1]
```
- **1つの命令**を**1つのデータ**に処理
- 普通のシングルコアPC

***

## SIMD（Single Instruction Multi Data）

```
  ↓
[命令]
  │
 ┌────────────┐
 │  [CPU]→[データ1]
 │  [CPU]→[データ2]
 └────────────┘
```
- **同じ命令**で**複数データ**を並列処理
- 画像編集やAI計算（GPU）

***

## MISD（Multi Instruction Single Data）

```
[命令1]→[CPU]→
[命令2]→[CPU]→[データ1]
```
- **複数の命令**を**1つのデータ**に対して処理
- 実際にはほとんど使われていない（特殊な計算機のみ）

***

## MIMD（Multi Instruction Multi Data）

```
  ↓           ↓
[命令1]    [命令2]
   │          │
[CPU1]→[データ1]
[CPU2]→[データ2]
```
- **複数の命令**で**複数のデータ**を並列処理
- サーバやマルチコアCPU（違うタスクを並行処理）

***

## イメージ早見メモ

|   タイプ   | 命令ストリーム | データストリーム | ざっくりイメージ           |
|:----------:|:-------------:|:---------------:|:--------------------------|
|    SISD    |      1        |       1         | 普通のシングルコア        |
|    SIMD    |      1        |      複数       | 同じ命令でみんなで処理    |
|    MISD    |     複数      |       1         | みんなで違うやり方で1個処理|
|    MIMD    |     複数      |      複数       | みんなで違う処理を同時実行 |

***

「どんなイメージ？」って聞かれたら、  
- SIMDは体育の「ラジオ体操」（全員同じ指示！）  
- MIMDは工場のライン作業みたいに、それぞれ別作業を同時進行



## GOAL
**CPUについて深く理解する**

***

## 主なトピック（TOPICS）

- 命令実行手順
- レジスタ
- アドレス指定方式
- 性能指標
    - CPI（Cycles Per Instruction）
    - MIPS（Million Instructions Per Second）
    - FLOPS（Floating Point Operations Per Second）
    - 命令ミックス
- 設計思想
    - CISC（Complex Instruction Set Computer）
    - RISC（Reduced Instruction Set Computer）
- 高速化
    - スーパースカラ
    - スーパーパイプライン

***

### 補足メモ

- **命令実行手順**：CPUが命令をどんな順番で処理するか
- **レジスタ**：CPU内部で使う高速な一時記憶領域。計算やデータ転送時に多用される
- **アドレス指定方式**：メモリ上のデータにどうアクセスするかのルール
- **性能指標**：
    - CPI：1命令ごとに何クロックかかるか
    - MIPS：1秒間に何百万命令処理できるか
    - FLOPS：浮動小数点演算の性能目安
    - 命令ミックス：どんな命令がよく使われるか
- **設計思想**：
    - CISC：命令が多機能＆複雑だけど、コードが短くて済む
    - RISC：単純な命令を高速に大量処理できる
- **高速化**：
    - スーパースカラ：複数命令を同時実行する技術
    - スーパーパイプライン：命令の細分化と並列実行で速度UP

***


***

# CPU命令実行サイクルのイメージ

## フェッチ → 解読 → オペランド読み出し → 命令実行

***

```
┌───────────────────────────────┐
│         汎用レジスタ           │          命令レジスタ
│       ┌───────────┐       ┌────────┐
│       │ データ     │←─┐    │命令    │─┬→ALU
│       │ 結果      │──┘    │プログラムカウンタ│
│                              │0006    │
└───────────────────────────────┘
   ↑                                    ↑
   │                                    │
   │                                    └───ALU（演算装置）で演算実行
   │
外部メモリ（RAMなど）

┌───────────────────────────────┐
│  0001 │ 0002 │ 0003 │ 0004 │ 0005 │ 0006 │
│  0007 │ 0008 │ 0009 │ 0010 │ 0011 │ 0012 │
└───────────────────────────────┘
```

***



1. **命令サイクル：**  
   上部の「フェッチ→解読→オペランド読み出し→命令実行」は、CPUが命令を処理するときの一連の流れだよ。

2. **レジスタ構成：**
   - 汎用レジスタ：計算するためのデータを一時的に保存。  
   - 命令レジスタ：今実行中の命令を格納。  
   - プログラムカウンタ：今どの命令を実行しているか番号で管理（例: 0006）

3. **命令とデータの流れ：**
   - 命令レジスタから命令がALU（演算装置）に送られる
   - 汎用レジスタからデータ→ALUへ。演算して結果を汎用レジスタに戻す

4. **メモリ：**
   - 下部は主記憶（メインRAMなど）のイメージ。ここから命令やデータを取り出して使う

***

## ワンポイント

- **汎用レジスタ**は作業台  
- **命令レジスタ**は指示書  
- **ALU**は計算機（Calculator）  
- **プログラムカウンタ**は実行中の命令番号を管理するカウンター

***

これがCPUの基本的な命令実行の流れ！  
「各部品の役割」や「処理順序」がイメージで掴めると思うよ。

気になる部分があればもっと詳しく解説できるから、ぜひ聞いてね！

プログラムカウンタが次の命令のメモリアドレスを指し、そこから命令を命令レジスタに取り込む。命令レジスタの内容に従い、ALUが計算を行い、データや計算結果は汎用レジスタに格納される。

## アドレス指定方式まとめ

コンピュータの命令は「命令部」と「オペランド部（データや番地）」で構成されているよ。  
オペランド部に何が入っているか、どうやってデータを指定するかによって「アドレス指定方式」が分かれるんだ！

---

### 1. 即値アドレス指定方式（イミディエイト方式）

- **特徴**：オペランド部に「生のデータ（値）」が直接入っている
- **イメージ**：「この命令で5を使ってね！」と命令の中に値が書いてある
- **例**：`MOV A, #5`（Aに5を入れる）

| 命令部 | オペランド部 |
|--------|--------------|
| 何する | 5（値そのもの）|

---

### 2. 直接アドレス指定方式

- **特徴**：オペランド部に「データが入っているメモリの番地」が書いてある
- **イメージ**：「この番地（アドレス）にあるデータを使ってね」
- **例**：`MOV A, 1000`（アドレス1000番地のデータをAに入れる）

| 命令部 | オペランド部 |
|--------|--------------|
| 何する | 1000（データが入っている番地）|

---

### 3. 間接アドレス指定方式

- **特徴**：オペランド部に「番地が書いてある番地」が入っている  
  つまり、まずオペランド部の番地に行き、そこに書いてある値を「本当の番地」として使う
- **イメージ**：「この番地に行って、そこに書いてある番地に本当のデータがあるよ」
- **例**：`MOV A, (2000)`（アドレス2000番地に書いてある値を番地として、その番地のデータをAに入れる）

| 命令部 | オペランド部 |
|--------|--------------|
| 何する | 2000（→その中身が本当の番地）|

- **ポイント**：コールバック関数みたいに「一手間かかる」けど、柔軟なデータ参照ができる！

---

### 4. インデックスアドレス指定方式

- **特徴**：オペランド部に「基準となる番地」と「インデックスレジスタ（加算値）」を組み合わせて、最終的な番地を決める方式
- **イメージ**：「配列のn番目」みたいに、基準アドレス＋インデックスでデータを順番にアクセスできる
- **例**：`MOV A, 3000(X)`（アドレス3000＋X番地のデータをAに入れる）

| 命令部 | オペランド部 |
|--------|--------------|
| 何する | 3000（基準）+ X（インデックスレジスタ）|

- **用途**：配列や連続データの処理に便利！  
  例：for文で配列を順番に処理する時など

---

### 5. ベースアドレス指定方式

- **特徴**：オペランド部に「基準となる番地（ベースアドレス）」と「ベースレジスタ」の値を加算して、最終的な番地を決める方式
- **イメージ**：「プログラムやデータのまとまり（領域）」の先頭をベースレジスタで管理し、そこからの相対位置でデータにアクセスする
- **例**：`MOV A, 0(B)`（ベースレジスタBの値＋0番地のデータをAに入れる）

| 命令部 | オペランド部 |
|--------|--------------|
| 何する | 0（オフセット）+ B（ベースレジスタ）|

- **用途**：プログラムの実行時にデータ領域やスタック領域の先頭が変わる場合など、柔軟なメモリアクセスに便利

---

### まとめ表

| 方式名                     | オペランド部の内容                 | 例（擬似命令）         | 特徴・用途                             |
|----------------------------|------------------------------------|------------------------|----------------------------------------|
| 即値アドレス指定方式       | 値そのもの                        | MOV A, #5              | 定数を使いたい時                       |
| 直接アドレス指定方式       | データの番地                      | MOV A, 1000            | 単純なメモリアクセス                   |
| 間接アドレス指定方式       | 番地が書いてある番地               | MOV A, (2000)          | 柔軟な参照、ポインタ的な使い方         |
| インデックスアドレス指定方式 | 基準番地＋インデックスレジスタ     | MOV A, 3000(X)         | 配列・連続データの処理に便利           |
| ベースアドレス指定方式     | オフセット＋ベースレジスタ         | MOV A, 0(B)            | プログラムやデータ領域の管理に便利     |

---


***

# 記憶階層構造（メモリ階層）

## はやい ←――――――――――――――――――――――――――→ おそい

```
[レジスタ] ＞ [キャッシュメモリ] ＞ [主記憶装置] ＞ [ディスクキャッシュ] ＞ [補助記憶装置]
```

- **レジスタ**：CPU内、最速・超少量
- **キャッシュメモリ**：CPU近く、かなり高速・容量小
- **主記憶装置**：RAMなど。容量大きくCPUよりは遅い
- **ディスクキャッシュ**：SSDやHDD近く、一時的に高速化
- **補助記憶装置**：SSD/HDD。大量保存、でもアクセスは遅い

***

## 容量小 ←――――――――――――→ 容量大

- 速いほど容量が小さい、遅いほど容量が大きい！

***

### イメージポイント

- 使う頻度が高いデータほど「より速い・少量の記憶」へ
- 長期保存・めったに使わないものは「より遅い・大容量」の記憶へ

***

覚えやすいように並べると  
**「レジスタ → キャッシュ → メインメモリ → ディスクキャッシュ → 補助記憶」**  
この順で「速さは下がる＆容量は増える」と覚えておこう！
---

# ライトバック方式とライトスルー方式

## キャッシュメモリの書き込み方式

CPUがキャッシュメモリを使ってデータを書き込むとき、主に「ライトバック方式」と「ライトスルー方式」の2つの方法があります。

| 方式名           | 特徴・動作                                                                 | メリット                                 | デメリット                                 |
|------------------|--------------------------------------------------------------------------|------------------------------------------|--------------------------------------------|
| ライトスルー方式 | 書き込み時に**キャッシュと主記憶の両方**に同時にデータを書き込む           | ・データの一貫性が保たれやすい<br>・設計が単純 | ・書き込み回数が多くなり、主記憶への負荷が高い |
| ライトバック方式 | 書き込み時は**キャッシュだけ**に書き込み、キャッシュから追い出す時に主記憶へ | ・主記憶への書き込み回数が減り高速<br>・効率的 | ・電源断時に主記憶と不一致の可能性<br>・制御が複雑 |

### イメージ

- **ライトスルー**：書いたらすぐ本棚（主記憶）にもコピー
- **ライトバック**：まず机（キャッシュ）にメモ、机から片付ける時に本棚へ

### 使い分け

- **ライトスルー方式**は、データの整合性が重要なシステムや設計がシンプルな場合に使われます。
- **ライトバック方式**は、書き込み頻度が高く、性能を重視する場合に使われます。

---
# DRAMとSRAMの比較

|                | **DRAM（Dynamic RAM）** | **SRAM（Static RAM）**    |
|:--------------:|:------------------------:|:-------------------------:|
| 構成部品       | コンデンサ                | フリップフロップ           |
| 集積度         | 高                        | 低                         |
| 価格           | 安価                      | 高価                       |
| 速度           | 遅い                      | 速い                       |
| リフレッシュ   | 必要                      | 不要                       |
| 主な用途       | メモリ                     | キャッシュ                  |

- DRAMは大容量・安価だが動作は遅く、定期的なリフレッシュが必要。主にメインメモリに使われる。
- SRAMは高速・高価で集積度は低いが、リフレッシュ不要。CPUのキャッシュなどに使われる。

# キャッシュとメモリ領域のアクセス時間

- 必要なデータがキャッシュにある時（ヒット）、速くアクセスできる
- キャッシュにない時（ミス）は、メインメモリからデータを取得するので遅くなる

## 実行アクセス時間（平均アクセス時間）

```
キャッシュメモリアクセス時間 × ヒット率
＋
主記憶アクセス時間 ×（1 − ヒット率）
```

- **ヒット率**：必要なデータがキャッシュに存在する割合
- キャッシュ領域、メモリ領域で分けて管理
    - 例）キャッシュ領域20MB、メモリ領域80MB

## ポイント

- キャッシュのヒット率が高いほど、全体のアクセス時間が短くなる
- キャッシュにミス（＝ヒットしない）すると、メモリ領域にアクセスするので遅くなる
- 実効アクセス時間は「速いアクセス」と「遅いアクセス」の加重平均で計算される


***

# ROM（Read Only Memory）まとめ

## ROMとは

- **読み出し専用のメモリ**  
  通常はデータの書き換えができない
- 電源OFFでも内容が消えない（不揮発性メモリ）
- 組み込み装置、BIOS、ファームウェアなどの「書き換えられたくない初期プログラム」保存に使う

***

## 代表的な記憶装置との違い（視覚的な整理）

```
┌─────────────┐
│   CPU       │
└────┬────────┘
     │
┌────▼─────┬──────────┬─────────┬─────┬─────┐
│ レジスタ │ キャッシュ │  RAM    │ ROM │ HDD │
└────┬─────┴──────────┴─────────┴─────┴─────┘
     │        │             │       │
  揮発性    揮発性        揮発性  不揮発性 不揮発性
  （電源切で消える）                （電源切っても保つ）
```

| 項目       | 内容                         |
|----------|----------------------------|
| **役割**   | 読み出し専用。ファームウェア/初期設定用        |
| **書き換え** | 基本不可（種類によっては一度だけ・限定的に可）    |
| **データ消失** | 電源OFFでも消えない（不揮発性）             |
| **速度**   | RAMと比べると遅いが、HDDより速めも多い         |
| **主な用途**| BIOS、組み込みデバイス、DVDなどのメディア    |
| **代表例** | マスクROM、EPROM、EEPROM、フラッシュメモリなど |

***

## ROMの主な種類

| 種類        | 特徴                               |
|:----------:|:----------------------------------|
| マスクROM   | 工場で一度だけ書き込む。書き換え不可。 |
| PROM       | 一度だけ書き込める。書き換え不可。     |
| EPROM      | 紫外線で全消去して再書き込み可能。     |
| EEPROM     | 電気的に消去・再書き込み可能。         |
| フラッシュメモリ | EEPROMの仲間、USBやSSDにも使われる。     |

***

## 【イメージ図解：ROMと記憶階層】
```
   [CPU]
     │
 ┌───┼────────┬─────────────┐
 │  RAM      │    ROM      │   HDD/SSD
 │ (作業用)  │（書換困難） │   (大量保存)
 │ 揮発性    │ 不揮発性    │   不揮発性
└───────────┴─────────────┘
```

- **RAM**：作業机　電源切ると消える
- **ROM**：金庫・マニュアル　電源切っても中身変わらない
- **HDD/SSD**：倉庫　大量で長期保存、読み書き自由

***
***

# RAID（レイド）とは？

RAID（Redundant Array of Independent Disks／独立ディスク冗長配列）は、複数のハードディスク（またはSSD）を組み合わせて、1台の大容量・高信頼性ストレージのように扱う技術です。

- **目的**：データの安全性向上（冗長化）、アクセス速度の向上、大容量化
- **主な用途**：サーバ、NAS、ワークステーションなど

***

## 主なRAIDレベルの種類と特徴

| レベル   | 特徴・仕組み                                         | メリット                   | デメリット                   |
|:-------:|:---------------------------------------------------|:-------------------------|:---------------------------|
| RAID 0  | 複数台にデータを分散（ストライピング）                | 高速化・大容量            | 故障時に全データ消失（冗長性なし） |
| RAID 1  | 同じデータを複数台に書き込む（ミラーリング）           | 高信頼性（片方壊れてもOK） | 容量効率が悪い（半分になる）      |
| RAID 5  | データ＋パリティ（誤り訂正情報）を分散して保存         | 高速＋冗長性＋容量効率     | 復旧に時間がかかる               |
| RAID 6  | RAID5のパリティを2重化（2台同時故障まで耐える）        | RAID5より高信頼性          | 書き込み速度やや低下             |
| RAID 10 | RAID1＋RAID0の組み合わせ（ミラー＋ストライピング）      | 高速＋高信頼性             | 容量効率は半分                  |

***

### RAIDレベルのイメージ図

- **RAID 0（ストライピング）**
  ```
  [データA1][データA2][データA3][データA4]...
   └→HDD1   └→HDD2   └→HDD1   └→HDD2 ...
  ```
  - データを交互に分散して書き込む。速いが壊れやすい。

- **RAID 1（ミラーリング）**
  ```
  [データA][データA]
   └→HDD1 └→HDD2
  ```
  - 同じ内容を2台に書き込む。どちらか壊れてもOK。

- **RAID 5**
  ```
  [データA][データB][パリティP]
   └→HDD1 └→HDD2 └→HDD3
  ```
  - 3台以上でデータ＋パリティを分散。1台壊れても復旧可能。

***

### RAIDの注意点

- RAIDは「バックアップの代わり」にはならない（誤操作やウイルスには無力）
- RAIDコントローラやソフトウェアで実現できる
- RAID構成によって必要なディスク台数や容量効率が異なる

***

## なぜROMがいるのか？

- 電源を落としても絶対消えたくない「初期プログラム」や「工場出荷時セットアップ」を維持するため
- 普通のパソコンやスマホにも必ず搭載

***

### 【まとめ】

- ROMは「絶対消したくない情報」「何度でも安全に保存」のための不揮発性メモリ
- RAMやHDD/SSDと役割・性質が違うので、階層メモリのなかで重要

***

# ハードウェア
## 代表的な5台装置

1. **レジスタ**
   - データを一時的に記憶する装置。
   - CPU内部で計算途中の値やアドレスなどを保持する。
   - 高速に読み書きできる。

2. **ALU（算術論理演算装置）**
   - Arithmetic Logic Unitの略。
   - 加算・減算などの算術演算や、AND・ORなどの論理演算を行う。
   - CPUの中核的な演算装置。

3. **制御装置**
   - プログラムの命令を解釈し、各装置に指示を出す。
   - 命令の取り出し、解読、実行の流れを制御する。

4. **主記憶装置（メインメモリ）**
   - プログラムやデータを一時的に保存する装置。
   - CPUが直接アクセスできる記憶領域（RAMなど）。

5. **入出力装置（I/O装置）**
   - コンピュータと外部（人や他の機器）とのデータのやり取りを行う装置。
   - 例：キーボード、ディスプレイ、プリンタ、USBメモリなど。



***

# 並列処理の分類

コンピュータの並列処理（パラレルプロセッシング）は、命令とデータの流れによって以下の4タイプに分けられるよ。

| 略称 | 名前（日本語）                | 名前（英語）                                       | 説明                                             |
|:----:|:--------------------------|:--------------------------------------------------|:------------------------------------------------|
| SISD | 単一命令・単一データ流      | Single Instruction Stream Single Data Stream      | 一般的な「順次処理」のCPU。1つの命令で1つのデータを処理。        |
| SIMD | 単一命令・複数データ流      | Single Instruction Stream Multi Data Stream       | 1つの命令で複数のデータを同時処理（画像処理やGPU等）。            |
| MISD | 複数命令・単一データ流      | Multi Instruction Stream Single Data Stream       | 複数の命令を1つのデータに適用。実際はほとんど使われない。         |
| MIMD | 複数命令・複数データ流      | Multi Instruction Stream Multi Data Stream        | 複数の命令で複数のデータを同時並行に処理（サーバ、マルチコアCPU等）。 |

***

## イメージ図（例）

- **SISD**：ふつうの1人作業
- **SIMD**：先生が同時にみんなに「同じ作業」を指示して、みんなで別のデータを処理
- **MISD**：みんなが同じデータをいろんなやり方で料理する
- **MIMD**：みんながバラバラの作業をバラバラのデータでやってる（複雑なチーム戦！）

***

### 補足
- 実際に使われているのは主にSISD、SIMD、MIMD
- SIMD：GPU（画像処理やAI計算で大活躍！）
- MIMD：サーバやデスクトップPCのマルチコアCPU

***

***

# 並列処理方式のグラフィカル解説

## SISD（Single Instruction Single Data）

```
[命令]→[CPU]→[データ1]
```
- **1つの命令**を**1つのデータ**に処理
- 普通のシングルコアPC

***

## SIMD（Single Instruction Multi Data）

```
  ↓
[命令]
  │
 ┌────────────┐
 │  [CPU]→[データ1]
 │  [CPU]→[データ2]
 └────────────┘
```
- **同じ命令**で**複数データ**を並列処理
- 画像編集やAI計算（GPU）

***

## MISD（Multi Instruction Single Data）

```
[命令1]→[CPU]→
[命令2]→[CPU]→[データ1]
```
- **複数の命令**を**1つのデータ**に対して処理
- 実際にはほとんど使われていない（特殊な計算機のみ）

***

## MIMD（Multi Instruction Multi Data）

```
  ↓           ↓
[命令1]    [命令2]
   │          │
[CPU1]→[データ1]
[CPU2]→[データ2]
```
- **複数の命令**で**複数のデータ**を並列処理
- サーバやマルチコアCPU（違うタスクを並行処理）

***

## イメージ早見メモ

|   タイプ   | 命令ストリーム | データストリーム | ざっくりイメージ           |
|:----------:|:-------------:|:---------------:|:--------------------------|
|    SISD    |      1        |       1         | 普通のシングルコア        |
|    SIMD    |      1        |      複数       | 同じ命令でみんなで処理    |
|    MISD    |     複数      |       1         | みんなで違うやり方で1個処理|
|    MIMD    |     複数      |      複数       | みんなで違う処理を同時実行 |

***

「どんなイメージ？」って聞かれたら、  
- SIMDは体育の「ラジオ体操」（全員同じ指示！）  
- MIMDは工場のライン作業みたいに、それぞれ別作業を同時進行



## GOAL
**CPUについて深く理解する**

***

## 主なトピック（TOPICS）

- 命令実行手順
- レジスタ
- アドレス指定方式
- 性能指標
    - CPI（Cycles Per Instruction）
    - MIPS（Million Instructions Per Second）
    - FLOPS（Floating Point Operations Per Second）
    - 命令ミックス
- 設計思想
    - CISC（Complex Instruction Set Computer）
    - RISC（Reduced Instruction Set Computer）
- 高速化
    - スーパースカラ
    - スーパーパイプライン

***

### 補足メモ

- **命令実行手順**：CPUが命令をどんな順番で処理するか
- **レジスタ**：CPU内部で使う高速な一時記憶領域。計算やデータ転送時に多用される
- **アドレス指定方式**：メモリ上のデータにどうアクセスするかのルール
- **性能指標**：
    - CPI：1命令ごとに何クロックかかるか
    - MIPS：1秒間に何百万命令処理できるか
    - FLOPS：浮動小数点演算の性能目安
    - 命令ミックス：どんな命令がよく使われるか
- **設計思想**：
    - CISC：命令が多機能＆複雑だけど、コードが短くて済む
    - RISC：単純な命令を高速に大量処理できる
- **高速化**：
    - スーパースカラ：複数命令を同時実行する技術
    - スーパーパイプライン：命令の細分化と並列実行で速度UP

***


***

# CPU命令実行サイクルのイメージ

## フェッチ → 解読 → オペランド読み出し → 命令実行

***

```
┌───────────────────────────────┐
│         汎用レジスタ           │          命令レジスタ
│       ┌───────────┐       ┌────────┐
│       │ データ     │←─┐    │命令    │─┬→ALU
│       │ 結果      │──┘    │プログラムカウンタ│
│                              │0006    │
└───────────────────────────────┘
   ↑                                    ↑
   │                                    │
   │                                    └───ALU（演算装置）で演算実行
   │
外部メモリ（RAMなど）

┌───────────────────────────────┐
│  0001 │ 0002 │ 0003 │ 0004 │ 0005 │ 0006 │
│  0007 │ 0008 │ 0009 │ 0010 │ 0011 │ 0012 │
└───────────────────────────────┘
```

***



1. **命令サイクル：**  
   上部の「フェッチ→解読→オペランド読み出し→命令実行」は、CPUが命令を処理するときの一連の流れだよ。

2. **レジスタ構成：**
   - 汎用レジスタ：計算するためのデータを一時的に保存。  
   - 命令レジスタ：今実行中の命令を格納。  
   - プログラムカウンタ：今どの命令を実行しているか番号で管理（例: 0006）

3. **命令とデータの流れ：**
   - 命令レジスタから命令がALU（演算装置）に送られる
   - 汎用レジスタからデータ→ALUへ。演算して結果を汎用レジスタに戻す

4. **メモリ：**
   - 下部は主記憶（メインRAMなど）のイメージ。ここから命令やデータを取り出して使う

***

## ワンポイント

- **汎用レジスタ**は作業台  
- **命令レジスタ**は指示書  
- **ALU**は計算機（Calculator）  
- **プログラムカウンタ**は実行中の命令番号を管理するカウンター

***

これがCPUの基本的な命令実行の流れ！  
「各部品の役割」や「処理順序」がイメージで掴めると思うよ。

気になる部分があればもっと詳しく解説できるから、ぜひ聞いてね！

プログラムカウンタが次の命令のメモリアドレスを指し、そこから命令を命令レジスタに取り込む。命令レジスタの内容に従い、ALUが計算を行い、データや計算結果は汎用レジスタに格納される。

## アドレス指定方式まとめ

コンピュータの命令は「命令部」と「オペランド部（データや番地）」で構成されているよ。  
オペランド部に何が入っているか、どうやってデータを指定するかによって「アドレス指定方式」が分かれるんだ！

---

### 1. 即値アドレス指定方式（イミディエイト方式）

- **特徴**：オペランド部に「生のデータ（値）」が直接入っている
- **イメージ**：「この命令で5を使ってね！」と命令の中に値が書いてある
- **例**：`MOV A, #5`（Aに5を入れる）

| 命令部 | オペランド部 |
|--------|--------------|
| 何する | 5（値そのもの）|

---

### 2. 直接アドレス指定方式

- **特徴**：オペランド部に「データが入っているメモリの番地」が書いてある
- **イメージ**：「この番地（アドレス）にあるデータを使ってね」
- **例**：`MOV A, 1000`（アドレス1000番地のデータをAに入れる）

| 命令部 | オペランド部 |
|--------|--------------|
| 何する | 1000（データが入っている番地）|

---

### 3. 間接アドレス指定方式

- **特徴**：オペランド部に「番地が書いてある番地」が入っている  
  つまり、まずオペランド部の番地に行き、そこに書いてある値を「本当の番地」として使う
- **イメージ**：「この番地に行って、そこに書いてある番地に本当のデータがあるよ」
- **例**：`MOV A, (2000)`（アドレス2000番地に書いてある値を番地として、その番地のデータをAに入れる）

| 命令部 | オペランド部 |
|--------|--------------|
| 何する | 2000（→その中身が本当の番地）|

- **ポイント**：コールバック関数みたいに「一手間かかる」けど、柔軟なデータ参照ができる！

---

### 4. インデックスアドレス指定方式

- **特徴**：オペランド部に「基準となる番地」と「インデックスレジスタ（加算値）」を組み合わせて、最終的な番地を決める方式
- **イメージ**：「配列のn番目」みたいに、基準アドレス＋インデックスでデータを順番にアクセスできる
- **例**：`MOV A, 3000(X)`（アドレス3000＋X番地のデータをAに入れる）

| 命令部 | オペランド部 |
|--------|--------------|
| 何する | 3000（基準）+ X（インデックスレジスタ）|

- **用途**：配列や連続データの処理に便利！  
  例：for文で配列を順番に処理する時など

---

### 5. ベースアドレス指定方式

- **特徴**：オペランド部に「基準となる番地（ベースアドレス）」と「ベースレジスタ」の値を加算して、最終的な番地を決める方式
- **イメージ**：「プログラムやデータのまとまり（領域）」の先頭をベースレジスタで管理し、そこからの相対位置でデータにアクセスする
- **例**：`MOV A, 0(B)`（ベースレジスタBの値＋0番地のデータをAに入れる）

| 命令部 | オペランド部 |
|--------|--------------|
| 何する | 0（オフセット）+ B（ベースレジスタ）|

- **用途**：プログラムの実行時にデータ領域やスタック領域の先頭が変わる場合など、柔軟なメモリアクセスに便利

---

### まとめ表

| 方式名                     | オペランド部の内容                 | 例（擬似命令）         | 特徴・用途                             |
|----------------------------|------------------------------------|------------------------|----------------------------------------|
| 即値アドレス指定方式       | 値そのもの                        | MOV A, #5              | 定数を使いたい時                       |
| 直接アドレス指定方式       | データの番地                      | MOV A, 1000            | 単純なメモリアクセス                   |
| 間接アドレス指定方式       | 番地が書いてある番地               | MOV A, (2000)          | 柔軟な参照、ポインタ的な使い方         |
| インデックスアドレス指定方式 | 基準番地＋インデックスレジスタ     | MOV A, 3000(X)         | 配列・連続データの処理に便利           |
| ベースアドレス指定方式     | オフセット＋ベースレジスタ         | MOV A, 0(B)            | プログラムやデータ領域の管理に便利     |

---


***

# 記憶階層構造（メモリ階層）

## はやい ←――――――――――――――――――――――――――→ おそい

```
[レジスタ] ＞ [キャッシュメモリ] ＞ [主記憶装置] ＞ [ディスクキャッシュ] ＞ [補助記憶装置]
```

- **レジスタ**：CPU内、最速・超少量
- **キャッシュメモリ**：CPU近く、かなり高速・容量小
- **主記憶装置**：RAMなど。容量大きくCPUよりは遅い
- **ディスクキャッシュ**：SSDやHDD近く、一時的に高速化
- **補助記憶装置**：SSD/HDD。大量保存、でもアクセスは遅い

***

## 容量小 ←――――――――――――→ 容量大

- 速いほど容量が小さい、遅いほど容量が大きい！

***

### イメージポイント

- 使う頻度が高いデータほど「より速い・少量の記憶」へ
- 長期保存・めったに使わないものは「より遅い・大容量」の記憶へ

***

覚えやすいように並べると  
**「レジスタ → キャッシュ → メインメモリ → ディスクキャッシュ → 補助記憶」**  
この順で「速さは下がる＆容量は増える」と覚えておこう！
---

# ライトバック方式とライトスルー方式

## キャッシュメモリの書き込み方式

CPUがキャッシュメモリを使ってデータを書き込むとき、主に「ライトバック方式」と「ライトスルー方式」の2つの方法があります。

| 方式名           | 特徴・動作                                                                 | メリット                                 | デメリット                                 |
|------------------|--------------------------------------------------------------------------|------------------------------------------|--------------------------------------------|
| ライトスルー方式 | 書き込み時に**キャッシュと主記憶の両方**に同時にデータを書き込む           | ・データの一貫性が保たれやすい<br>・設計が単純 | ・書き込み回数が多くなり、主記憶への負荷が高い |
| ライトバック方式 | 書き込み時は**キャッシュだけ**に書き込み、キャッシュから追い出す時に主記憶へ | ・主記憶への書き込み回数が減り高速<br>・効率的 | ・電源断時に主記憶と不一致の可能性<br>・制御が複雑 |

### イメージ

- **ライトスルー**：書いたらすぐ本棚（主記憶）にもコピー
- **ライトバック**：まず机（キャッシュ）にメモ、机から片付ける時に本棚へ

### 使い分け

- **ライトスルー方式**は、データの整合性が重要なシステムや設計がシンプルな場合に使われます。
- **ライトバック方式**は、書き込み頻度が高く、性能を重視する場合に使われます。

---
# DRAMとSRAMの比較

|                | **DRAM（Dynamic RAM）** | **SRAM（Static RAM）**    |
|:--------------:|:------------------------:|:-------------------------:|
| 構成部品       | コンデンサ                | フリップフロップ           |
| 集積度         | 高                        | 低                         |
| 価格           | 安価                      | 高価                       |
| 速度           | 遅い                      | 速い                       |
| リフレッシュ   | 必要                      | 不要                       |
| 主な用途       | メモリ                     | キャッシュ                  |

- DRAMは大容量・安価だが動作は遅く、定期的なリフレッシュが必要。主にメインメモリに使われる。
- SRAMは高速・高価で集積度は低いが、リフレッシュ不要。CPUのキャッシュなどに使われる。

# キャッシュとメモリ領域のアクセス時間

- 必要なデータがキャッシュにある時（ヒット）、速くアクセスできる
- キャッシュにない時（ミス）は、メインメモリからデータを取得するので遅くなる

## 実行アクセス時間（平均アクセス時間）

```
キャッシュメモリアクセス時間 × ヒット率
＋
主記憶アクセス時間 ×（1 − ヒット率）
```

- **ヒット率**：必要なデータがキャッシュに存在する割合
- キャッシュ領域、メモリ領域で分けて管理
    - 例）キャッシュ領域20MB、メモリ領域80MB

## ポイント

- キャッシュのヒット率が高いほど、全体のアクセス時間が短くなる
- キャッシュにミス（＝ヒットしない）すると、メモリ領域にアクセスするので遅くなる
- 実効アクセス時間は「速いアクセス」と「遅いアクセス」の加重平均で計算される


***

# ROM（Read Only Memory）まとめ

## ROMとは

- **読み出し専用のメモリ**  
  通常はデータの書き換えができない
- 電源OFFでも内容が消えない（不揮発性メモリ）
- 組み込み装置、BIOS、ファームウェアなどの「書き換えられたくない初期プログラム」保存に使う

***

## 代表的な記憶装置との違い（視覚的な整理）

```
┌─────────────┐
│   CPU       │
└────┬────────┘
     │
┌────▼─────┬──────────┬─────────┬─────┬─────┐
│ レジスタ │ キャッシュ │  RAM    │ ROM │ HDD │
└────┬─────┴──────────┴─────────┴─────┴─────┘
     │        │             │       │
  揮発性    揮発性        揮発性  不揮発性 不揮発性
  （電源切で消える）                （電源切っても保つ）
```

| 項目       | 内容                         |
|----------|----------------------------|
| **役割**   | 読み出し専用。ファームウェア/初期設定用        |
| **書き換え** | 基本不可（種類によっては一度だけ・限定的に可）    |
| **データ消失** | 電源OFFでも消えない（不揮発性）             |
| **速度**   | RAMと比べると遅いが、HDDより速めも多い         |
| **主な用途**| BIOS、組み込みデバイス、DVDなどのメディア    |
| **代表例** | マスクROM、EPROM、EEPROM、フラッシュメモリなど |

***

## ROMの主な種類

| 種類        | 特徴                               |
|:----------:|:----------------------------------|
| マスクROM   | 工場で一度だけ書き込む。書き換え不可。 |
| PROM       | 一度だけ書き込める。書き換え不可。     |
| EPROM      | 紫外線で全消去して再書き込み可能。     |
| EEPROM     | 電気的に消去・再書き込み可能。         |
| フラッシュメモリ | EEPROMの仲間、USBやSSDにも使われる。     |

***

## 【イメージ図解：ROMと記憶階層】
```
   [CPU]
     │
 ┌───┼────────┬─────────────┐
 │  RAM      │    ROM      │   HDD/SSD
 │ (作業用)  │（書換困難） │   (大量保存)
 │ 揮発性    │ 不揮発性    │   不揮発性
└───────────┴─────────────┘
```

- **RAM**：作業机　電源切ると消える
- **ROM**：金庫・マニュアル　電源切っても中身変わらない
- **HDD/SSD**：倉庫　大量で長期保存、読み書き自由

***
***

# RAID（レイド）とは？

RAID（Redundant Array of Independent Disks／独立ディスク冗長配列）は、複数のハードディスク（またはSSD）を組み合わせて、1台の大容量・高信頼性ストレージのように扱う技術です。

- **目的**：データの安全性向上（冗長化）、アクセス速度の向上、大容量化
- **主な用途**：サーバ、NAS、ワークステーションなど

***

## 主なRAIDレベルの種類と特徴

| レベル   | 特徴・仕組み                                         | メリット                   | デメリット                   |
|:-------:|:---------------------------------------------------|:-------------------------|:---------------------------|
| RAID 0  | 複数台にデータを分散（ストライピング）                | 高速化・大容量            | 故障時に全データ消失（冗長性なし） |
| RAID 1  | 同じデータを複数台に書き込む（ミラーリング）           | 高信頼性（片方壊れてもOK） | 容量効率が悪い（半分になる）      |
| RAID 5  | データ＋パリティ（誤り訂正情報）を分散して保存         | 高速＋冗長性＋容量効率     | 復旧に時間がかかる               |
| RAID 6  | RAID5のパリティを2重化（2台同時故障まで耐える）        | RAID5より高信頼性          | 書き込み速度やや低下             |
| RAID 10 | RAID1＋RAID0の組み合わせ（ミラー＋ストライピング）      | 高速＋高信頼性             | 容量効率は半分                  |

***

### RAIDレベルのイメージ図

- **RAID 0（ストライピング）**
  ```
  [データA1][データA2][データA3][データA4]...
   └→HDD1   └→HDD2   └→HDD1   └→HDD2 ...
  ```
  - データを交互に分散して書き込む。速いが壊れやすい。

- **RAID 1（ミラーリング）**
  ```
  [データA][データA]
   └→HDD1 └→HDD2
  ```
  - 同じ内容を2台に書き込む。どちらか壊れてもOK。

- **RAID 5**
  ```
  [データA][データB][パリティP]
   └→HDD1 └→HDD2 └→HDD3
  ```
  - 3台以上でデータ＋パリティを分散。1台壊れても復旧可能。

***

### RAIDの注意点

- RAIDは「バックアップの代わり」にはならない（誤操作やウイルスには無力）
- RAIDコントローラやソフトウェアで実現できる
- RAID構成によって必要なディスク台数や容量効率が異なる

***

## なぜROMがいるのか？

- 電源を落としても絶対消えたくない「初期プログラム」や「工場出荷時セットアップ」を維持するため
- 普通のパソコンやスマホにも必ず搭載

***

### 【まとめ】

- ROMは「絶対消したくない情報」「何度でも安全に保存」のための不揮発性メモリ
- RAMやHDD/SSDと役割・性質が違うので、階層メモリのなかで重要

***



***



## システムの変遷（発展の流れ）

| フェーズ      | 内容                                                         | 台数          | 形態           |
|:-------------|:------------------------------------------------------------|:-------------|:--------------|
| バッチ処理    | プログラムカード等でまとめて実行し、結果を待つ                | 1台           | スタンドアロン  |
| TSS           | ホストを時間分割し複数端末で共有利用                          | 1台           | スタンドアロン  |
| ネットワーク   | 複数コンピュータを接続し、多様な処理を行う                   | 複数台        | ネットワーク    |
| インターネット | 世界中の端末で通信が可能                                     | 全世界        | ネットワーク    |

***

## システムの形態

```
[集中特化]
   サーバ
     │
端末─┼─端末 ─端末

[分散協調]
       クラウド
      ／  |   ＼
   PC   PC    PC ...
```

- **集中処理**：サーバが管理、端末は「Client」
- **分散処理**：複数端末がクラウド等で連携・処理

***

## 信頼性向上を目指すシステム構成

| デュプレックスシステム        | デュアルシステム            |
|:----------------------------:|:---------------------------:|
| メイン機が故障時のみ予備が稼働 | 普段から2台同時に同じ処理    |

***

## サービスの分類

- **SaaS**（Software as a Service）：アプリごと提供  
- **PaaS**（Platform as a Service）：開発プラットフォームごと提供  
- **IaaS**（Infrastructure as a Service）：仮想サーバ等インフラごと提供  

***

## クラウド・エッジ・P2P等

- **クラウドコンピューティング**：ネット越しの計算資源
- **エッジコンピューティング**：利用者近くで分散処理
- **P2P**：端末同士で直接やりとり

***

## 信頼性設計の用語

| 用語                   | 意味                                 |
|:-----------------------|:-------------------------------------|
| フォールトトレラント     | 故障後も稼働し続ける設計              |
| フォールトアボイダンス   | 故障予防を重視した設計                |
| フェールセーフ          | 故障時の被害を最小化                  |
| フェールソフト          | 一部機能停止で全体停止を避ける         |
| フールプルーフ          | 操作ミス自体を防ぐ                     |

- **RASIS**：信頼性（Reliability）、可用性（Availability）、保守性（Serviceability）、保全性（Integrity）、安全性（Security）
- **MTBF**：平均故障間隔
- **MTTR**：平均修理時間

***
# クライアントサーバシステム

- サーバが複数のクライアント（PC、端末）と接続
- 必要に応じて集中処理（サーバ側）・分散処理（クライアント側）を使い分ける

***

# クラウドサービスの構造

| 層              | サービス                      |
|:---------------|:----------------------------|
| アプリケーション | SaaS (Software as a Service)      |
| ミドルウェア/API |                              |
| OS              | PaaS (Platform as a Service)      |
| サーバ本体       | IaaS (Infrastructure as a Service) |

- どの機能を含むかで呼び方が異なる

***

# RASIS（システム設計に求められる5つの特性）

- Reliability（信頼性）：正常に稼働し続ける
- Availability（可用性）：使いたい時に使える
- Serviceability（保守性）：修理や点検のしやすさ
- Integrity（完全性）：データの正しさ・一貫性
- Security（機密性）：不正アクセスや情報漏洩の防御

***

# MTTR・MTBF

- MTTR（Mean Time to Recovery）：平均復旧時間  
  故障→修理までにかかる平均時間

- MTBF（Mean Time Between Failures）：平均故障間隔  
  稼働から次に故障するまでの平均時間

- 稼働率（Uptime）の計算式
  ```
  Uptime = MTBF / (MTTR + MTBF)
  ```

- 稼働と故障・修理のタイムラインイメージ
  ```
  [稼働]→[故障・修理]→[稼働]→...
  ```

