2進数とかそこらへんはわかる

## 基数変換

### 10進数から2進数への変換手順

例えば、`123` を2進数に変換する場合：

| 割る数 | 商   | 余り |
|:------:|:----:|:----:|
| 2      | 123 ÷ 2 = 61 | **1** |
| 2      | 61 ÷ 2 = 30  | **1** |
| 2      | 30 ÷ 2 = 15  | **0** |
| 2      | 15 ÷ 2 = 7   | **1** |
| 2      | 7 ÷ 2 = 3    | **1** |
| 2      | 3 ÷ 2 = 1    | **1** |
|        | 1             | **1** |

余りを下から上へ並べると  
**1111011** が答えとなる。


### 論理演算

論理演算は、ビットごとに行う演算で、主に以下の種類

| 演算子 | 名前         | 説明                                 | 例（2進数）      |
|:------:|:------------|:-------------------------------------|:----------------|
| AND    | 論理積      | 両方が1のとき1                       | 1101 & 1011 = 1001 |
| OR     | 論理和      | どちらかが1のとき1                   | 1101 \| 1011 = 1111 |
| XOR    | 排他的論理和| どちらか一方のみ1のとき1             | 1101 ^ 1011 = 0110 |
| NOT    | 否定        | 0は1に、1は0に反転                   | ~1101 = ...0010（符号ビットに注意） |

#### AND（&）
- 両方のビットが1のときだけ1になる。
- 例: 1101 & 1011 = 1001

#### OR（|）
- どちらかのビットが1なら1になる。
- 例: 1101 | 1011 = 1111

#### XOR（^）
- どちらか一方だけが1のとき1になる。
- 例: 1101 ^ 1011 = 0110

#### NOT（~）
- ビットを反転する（0→1, 1→0）。
- 例: ~1101 = ...0010（符号付き整数の場合は注意）

#### シフト演算
- 左シフト（<<）：ビットを左にずらす（2倍するのと同じ）
- 右シフト（>>）：ビットを右にずらす（2で割るのと同じ、符号に注意）

#### 使いどころ
- フラグ管理
- マスク処理
- 高速な計算や状態管理

---

### 補数を用いた減算

2進数の減算は、**補数**（特に2の補数）を使うことで「加算」として計算できる。  
これにより、コンピュータは減算回路を持たずに済む。

#### 2の補数とは？

- ある数値のビットをすべて反転（NOT）し、1を足したものが「2の補数」。
- 例：4ビットで 5（0101）の2の補数を求める  
  1. ビット反転：0101 → 1010  
  2. 1を加える：1010 + 1 = 1011

#### 減算の例：7 - 5 を4ビットで計算

| 10進数 | 2進数（4ビット） |
|:------:|:----------------:|
| 7      | 0111             |
| 5      | 0101             |

1. 5の2の補数を求める  
   - 0101 → 1010（反転）→ 1011（+1）

2. 7 + (5の2の補数) を計算  
   ```
     0111   (7)
   + 1011   (5の2の補数)
   --------
    1 0010
   ```
   - 5ビット目の「1」は桁あふれ（キャリー）なので捨てる
   - 残りは 0010（2進数）→ 2（10進数）

3. 結果：7 - 5 = 2





***
## シフト演算について
### ～なんでもいいからとりあえずずらしてしまう～

### 2ⁿ倍したい

```
00001101
```

↓ nだけ左にずらす

```
0000110100
```

- 「nだけ左にずらす」とは、nビットだけ左シフトすること
- 2ⁿ倍したいときは、n回左シフト！

***

### サンプル説明

- 例: `00001101` を2ビット左にずらす（n=2の場合）
- `00001101` → `0000110100`

この操作で「2のn乗倍」になる、ということ！

***

#### コード例（Python）

```python
x = 0b00001101 # 13
n = 2
result = x << n
print(bin(result))  # 0b110100 (つまり52)
```

***




### 1/2ⁿ倍したい

```
00001101  (13)
```

↓ nだけ右にずらす

```
00000011  (3)
```

- 「nだけ右にずらす」とは、nビットだけ右シフトすること！
- 1/2ⁿ倍したいときは、n回右シフト！

***

### サンプル説明

- 例: `00001101` を2ビット右にずらす（n=2の場合）
- `00001101` → `00000011`
- つまり13 → 3になっている！

***

#### コード例（Python）

```python
x = 0b00001101  # 13
n = 2
result = x >> n
print(result)   # 3
```

***

### ワンポイント

- 左シフトは「かけ算（2のn乗倍）」、右シフトは「割り算（1/2のn乗倍）」になるよ！
- 小数点以下が出る場合は切り捨てになるので注意！

***

### 算術シフトについて

#### 算術シフトとは？

- **算術シフト**は、符号付き整数（二進数）に対してビットシフトを行う操作です。
- 主に「左算術シフト（左シフト）」と「右算術シフト（右シフト）」があります。

#### 算術右シフト

- **算術右シフト**は、符号ビット（最上位ビット）を保持したまま右にビットをずらします。
- 負の数の場合、左端（符号ビット）は1のまま埋められます（符号拡張）。
- 例：
    - `11111000`（-8）を2ビット算術右シフト → `11111110`（-2）

#### 算術左シフト

- **算術左シフト**は、通常の左シフトと同じで、右端に0を埋めます。
- 符号ビットもシフトされるため、オーバーフローに注意！

#### 算術シフトと論理シフトの違い

- **論理シフト**は、符号を考慮せず、空いたビットを0で埋めます。
- **算術シフト**は、右シフト時に符号ビットを維持します（負の数の扱いが異なる）。

#### Pythonでの算術シフト

- Pythonの`>>`演算子は、符号付き整数に対して算術右シフトを行います。


# 情報理論

データを早く正確に送りたい
データを1と０で表したものをバイナリ

早く届けるために圧縮というものを行う
符号化してから圧縮

---

### 可逆圧縮と不可逆圧縮

#### 可逆圧縮（ロスレス圧縮）

- 圧縮前のデータを**完全に元に戻せる**圧縮方法。
- 主にテキストやプログラム、重要な画像・音声データなど、情報の欠損が許されない場合に使われる。
- 例：
    - ZIP（ファイル圧縮）
    - PNG（画像）
    - GIF（画像）
    - FLAC（音声）

#### 不可逆圧縮（ロッシー圧縮）

- 圧縮前のデータを**完全には元に戻せない**圧縮方法。人間が気づきにくい情報を削除してデータ量を減らす。
- 主に画像・音声・動画など、多少の情報の欠損が許容される場合に使われる。
- 例：
    - JPEG（画像）
    - MP3（音声）
    - AAC（音声）
    - MPEG4（動画）

---

### パリティチェック

#### パリティとは

- **パリティ**とは、データのビット列に対して「1の個数が偶数か奇数か」を利用して誤り検出を行う方法です。

#### パリティビット

- データの末尾などに1ビット追加し、全体の1の個数が「偶数」または「奇数」になるようにします。
    - **偶数パリティ**：1の個数が偶数になるようにパリティビットを設定
    - **奇数パリティ**：1の個数が奇数になるようにパリティビットを設定

#### 例

- 送信データ: `1011001`（1の個数は4つ、偶数）
    - 偶数パリティの場合 → パリティビットは`0`（そのままで偶数）
    - 奇数パリティの場合 → パリティビットは`1`（1を足して奇数にする）

#### パリティチェックの用途

- データ伝送時の**単純な誤り検出**に使われる（1ビットの誤りは検出できるが、2ビットの誤りは検出できない）

#### Pythonでのパリティビット計算例

---

### ハフマン符号化

#### ハフマン符号化とは

- **ハフマン符号化**は、データ圧縮で使われる可変長符号化方式の一つです。
- 出現頻度が高いデータには短いビット列、頻度が低いデータには長いビット列を割り当てることで、全体のデータ量を削減します。
- 主に可逆圧縮（ロスレス圧縮）で利用されます。

#### ハフマン木の構築手順

1. 各文字とその出現頻度（重み）をノードとして用意する。
2. 最も重みが小さいノード2つを選び、それらを子とする新しいノードを作る（重みは2つの合計）。
3. 新しいノードをノード集合に追加し、元の2つは削除する。
4. ノードが1つになるまで2,3を繰り返す。
5. 最後にできた木が**ハフマン木**となる。

#### ハフマン符号の特徴

- 各文字に割り当てられるビット列は**プレフィックス符号**（どの符号も他の符号の前半部分にならない）となるため、復号が容易。
- 最適な符号長を実現できる（情報理論的に最小の平均符号長）。

#### 例

| 文字 | 頻度 | 割り当てられる符号例 |
|------|------|----------------------|
| A    | 5    | 0                    |
| B    | 2    | 10                   |
| C    | 1    | 110                  |
| D    | 1    | 111                  |


***


XOR（排他的論理和）など、紛らわしい論理演算回路の心理地図的メモを書いてみるね。感覚的に整理できるようにしてみたよ。

***


### 1. AND（論理積）
- **イメージ**：両方が「YES（1）」ならOK
- みんなで協力して「両方が真」じゃないとダメな時に使う
- 入力が両方1のときだけ出力1、それ以外は0

***

### 2. OR（論理和）
- **イメージ**：どちらか1つでも「YES（1）」ならOK
- 「どっちかが真なら結果も真」って意味
- 少なくとも1つが1なら出力1

***

### 3. XOR（排他的論理和）
- **イメージ**：「どちらか一方だけYES（1）ならOK」だけど、両方同時はダメ
- 「違いをチェックする」スイッチみたいな感じ
- 入力が異なるときだけ出力1、同じなら0

***

### 4. NAND（否定論理積）
- **イメージ**：「ANDの逆」
- 「両方が1じゃなければOK」みたいなノリ
- ANDの結果を反転させたもの

***

### 5. NOR（否定論理和）
- **イメージ**：「ORの逆」
- どちらも0（NO）のときだけOK
- ORの結果を反転させたもの

***

### 6. XNOR（論理一致素子）
- **イメージ**：「XORの逆」
- 入力が同じだったら1（YES）を返す
- 「一致チェック装置」

***

### 7. NOT（論理否定器）
- **イメージ**：単純に「YESかNOをひっくり返す」
- 1→0、0→1

***

### 覚え方のコツ

- AND, ORは「みんなで集まるか、どちらかがOKか」
- XORは「違うかどうかを判定する関数」
- NAND, NORは、それぞれAND, ORの「裏（反転）」バージョン
- XNORはXORの「一致してるよ」の逆
- NOTは「真偽をひっくり返す」

***

# ハードウェア
## 代表的な5台装置

1. **レジスタ**
   - データを一時的に記憶する装置。
   - CPU内部で計算途中の値やアドレスなどを保持する。
   - 高速に読み書きできる。

2. **ALU（算術論理演算装置）**
   - Arithmetic Logic Unitの略。
   - 加算・減算などの算術演算や、AND・ORなどの論理演算を行う。
   - CPUの中核的な演算装置。

3. **制御装置**
   - プログラムの命令を解釈し、各装置に指示を出す。
   - 命令の取り出し、解読、実行の流れを制御する。

4. **主記憶装置（メインメモリ）**
   - プログラムやデータを一時的に保存する装置。
   - CPUが直接アクセスできる記憶領域（RAMなど）。

5. **入出力装置（I/O装置）**
   - コンピュータと外部（人や他の機器）とのデータのやり取りを行う装置。
   - 例：キーボード、ディスプレイ、プリンタ、USBメモリなど。



***

# 並列処理の分類

コンピュータの並列処理（パラレルプロセッシング）は、命令とデータの流れによって以下の4タイプに分けられるよ。

| 略称 | 名前（日本語）                | 名前（英語）                                       | 説明                                             |
|:----:|:--------------------------|:--------------------------------------------------|:------------------------------------------------|
| SISD | 単一命令・単一データ流      | Single Instruction Stream Single Data Stream      | 一般的な「順次処理」のCPU。1つの命令で1つのデータを処理。        |
| SIMD | 単一命令・複数データ流      | Single Instruction Stream Multi Data Stream       | 1つの命令で複数のデータを同時処理（画像処理やGPU等）。            |
| MISD | 複数命令・単一データ流      | Multi Instruction Stream Single Data Stream       | 複数の命令を1つのデータに適用。実際はほとんど使われない。         |
| MIMD | 複数命令・複数データ流      | Multi Instruction Stream Multi Data Stream        | 複数の命令で複数のデータを同時並行に処理（サーバ、マルチコアCPU等）。 |

***

## イメージ図（例）

- **SISD**：ふつうの1人作業
- **SIMD**：先生が同時にみんなに「同じ作業」を指示して、みんなで別のデータを処理
- **MISD**：みんなが同じデータをいろんなやり方で料理する
- **MIMD**：みんながバラバラの作業をバラバラのデータでやってる（複雑なチーム戦！）

***

### 補足
- 実際に使われているのは主にSISD、SIMD、MIMD
- SIMD：GPU（画像処理やAI計算で大活躍！）
- MIMD：サーバやデスクトップPCのマルチコアCPU

***

