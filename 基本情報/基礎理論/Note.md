2進数とかそこらへんはわかる

## 基数変換

### 10進数から2進数への変換手順

例えば、`123` を2進数に変換する場合：

| 割る数 | 商   | 余り |
|:------:|:----:|:----:|
| 2      | 123 ÷ 2 = 61 | **1** |
| 2      | 61 ÷ 2 = 30  | **1** |
| 2      | 30 ÷ 2 = 15  | **0** |
| 2      | 15 ÷ 2 = 7   | **1** |
| 2      | 7 ÷ 2 = 3    | **1** |
| 2      | 3 ÷ 2 = 1    | **1** |
|        | 1             | **1** |

余りを下から上へ並べると  
**1111011** が答えとなる。


### 論理演算

論理演算は、ビットごとに行う演算で、主に以下の種類

| 演算子 | 名前         | 説明                                 | 例（2進数）      |
|:------:|:------------|:-------------------------------------|:----------------|
| AND    | 論理積      | 両方が1のとき1                       | 1101 & 1011 = 1001 |
| OR     | 論理和      | どちらかが1のとき1                   | 1101 \| 1011 = 1111 |
| XOR    | 排他的論理和| どちらか一方のみ1のとき1             | 1101 ^ 1011 = 0110 |
| NOT    | 否定        | 0は1に、1は0に反転                   | ~1101 = ...0010（符号ビットに注意） |

#### AND（&）
- 両方のビットが1のときだけ1になる。
- 例: 1101 & 1011 = 1001

#### OR（|）
- どちらかのビットが1なら1になる。
- 例: 1101 | 1011 = 1111

#### XOR（^）
- どちらか一方だけが1のとき1になる。
- 例: 1101 ^ 1011 = 0110

#### NOT（~）
- ビットを反転する（0→1, 1→0）。
- 例: ~1101 = ...0010（符号付き整数の場合は注意）

#### シフト演算
- 左シフト（<<）：ビットを左にずらす（2倍するのと同じ）
- 右シフト（>>）：ビットを右にずらす（2で割るのと同じ、符号に注意）

#### 使いどころ
- フラグ管理
- マスク処理
- 高速な計算や状態管理

---

### 補数を用いた減算

2進数の減算は、**補数**（特に2の補数）を使うことで「加算」として計算できる。  
これにより、コンピュータは減算回路を持たずに済む。

#### 2の補数とは？

- ある数値のビットをすべて反転（NOT）し、1を足したものが「2の補数」。
- 例：4ビットで 5（0101）の2の補数を求める  
  1. ビット反転：0101 → 1010  
  2. 1を加える：1010 + 1 = 1011

#### 減算の例：7 - 5 を4ビットで計算

| 10進数 | 2進数（4ビット） |
|:------:|:----------------:|
| 7      | 0111             |
| 5      | 0101             |

1. 5の2の補数を求める  
   - 0101 → 1010（反転）→ 1011（+1）

2. 7 + (5の2の補数) を計算  
   ```
     0111   (7)
   + 1011   (5の2の補数)
   --------
    1 0010
   ```
   - 5ビット目の「1」は桁あふれ（キャリー）なので捨てる
   - 残りは 0010（2進数）→ 2（10進数）

3. 結果：7 - 5 = 2





***
## シフト演算について
### ～なんでもいいからとりあえずずらしてしまう～

### 2ⁿ倍したい

```
00001101
```

↓ nだけ左にずらす

```
0000110100
```

- 「nだけ左にずらす」とは、nビットだけ左シフトすること
- 2ⁿ倍したいときは、n回左シフト！

***

### サンプル説明

- 例: `00001101` を2ビット左にずらす（n=2の場合）
- `00001101` → `0000110100`

この操作で「2のn乗倍」になる、ということ！

***

#### コード例（Python）

```python
x = 0b00001101 # 13
n = 2
result = x << n
print(bin(result))  # 0b110100 (つまり52)
```

***




### 1/2ⁿ倍したい

```
00001101  (13)
```

↓ nだけ右にずらす

```
00000011  (3)
```

- 「nだけ右にずらす」とは、nビットだけ右シフトすること！
- 1/2ⁿ倍したいときは、n回右シフト！

***

### サンプル説明

- 例: `00001101` を2ビット右にずらす（n=2の場合）
- `00001101` → `00000011`
- つまり13 → 3になっている！

***

#### コード例（Python）

```python
x = 0b00001101  # 13
n = 2
result = x >> n
print(result)   # 3
```

***

### ワンポイント

- 左シフトは「かけ算（2のn乗倍）」、右シフトは「割り算（1/2のn乗倍）」になるよ！
- 小数点以下が出る場合は切り捨てになるので注意！

***

### 算術シフトについて

#### 算術シフトとは？

- **算術シフト**は、符号付き整数（二進数）に対してビットシフトを行う操作です。
- 主に「左算術シフト（左シフト）」と「右算術シフト（右シフト）」があります。

#### 算術右シフト

- **算術右シフト**は、符号ビット（最上位ビット）を保持したまま右にビットをずらします。
- 負の数の場合、左端（符号ビット）は1のまま埋められます（符号拡張）。
- 例：
    - `11111000`（-8）を2ビット算術右シフト → `11111110`（-2）

#### 算術左シフト

- **算術左シフト**は、通常の左シフトと同じで、右端に0を埋めます。
- 符号ビットもシフトされるため、オーバーフローに注意！

#### 算術シフトと論理シフトの違い

- **論理シフト**は、符号を考慮せず、空いたビットを0で埋めます。
- **算術シフト**は、右シフト時に符号ビットを維持します（負の数の扱いが異なる）。

#### Pythonでの算術シフト

- Pythonの`>>`演算子は、符号付き整数に対して算術右シフトを行います。


# 情報理論

データを早く正確に送りたい
データを1と０で表したものをバイナリ

早く届けるために圧縮というものを行う
符号化してから圧縮

---

### 可逆圧縮と不可逆圧縮

#### 可逆圧縮（ロスレス圧縮）

- 圧縮前のデータを**完全に元に戻せる**圧縮方法。
- 主にテキストやプログラム、重要な画像・音声データなど、情報の欠損が許されない場合に使われる。
- 例：
    - ZIP（ファイル圧縮）
    - PNG（画像）
    - GIF（画像）
    - FLAC（音声）

#### 不可逆圧縮（ロッシー圧縮）

- 圧縮前のデータを**完全には元に戻せない**圧縮方法。人間が気づきにくい情報を削除してデータ量を減らす。
- 主に画像・音声・動画など、多少の情報の欠損が許容される場合に使われる。
- 例：
    - JPEG（画像）
    - MP3（音声）
    - AAC（音声）
    - MPEG4（動画）

---

### パリティチェック

#### パリティとは

- **パリティ**とは、データのビット列に対して「1の個数が偶数か奇数か」を利用して誤り検出を行う方法です。

#### パリティビット

- データの末尾などに1ビット追加し、全体の1の個数が「偶数」または「奇数」になるようにします。
    - **偶数パリティ**：1の個数が偶数になるようにパリティビットを設定
    - **奇数パリティ**：1の個数が奇数になるようにパリティビットを設定

#### 例

- 送信データ: `1011001`（1の個数は4つ、偶数）
    - 偶数パリティの場合 → パリティビットは`0`（そのままで偶数）
    - 奇数パリティの場合 → パリティビットは`1`（1を足して奇数にする）

#### パリティチェックの用途

- データ伝送時の**単純な誤り検出**に使われる（1ビットの誤りは検出できるが、2ビットの誤りは検出できない）

#### Pythonでのパリティビット計算例

---

### ハフマン符号化

#### ハフマン符号化とは

- **ハフマン符号化**は、データ圧縮で使われる可変長符号化方式の一つです。
- 出現頻度が高いデータには短いビット列、頻度が低いデータには長いビット列を割り当てることで、全体のデータ量を削減します。
- 主に可逆圧縮（ロスレス圧縮）で利用されます。

#### ハフマン木の構築手順

1. 各文字とその出現頻度（重み）をノードとして用意する。
2. 最も重みが小さいノード2つを選び、それらを子とする新しいノードを作る（重みは2つの合計）。
3. 新しいノードをノード集合に追加し、元の2つは削除する。
4. ノードが1つになるまで2,3を繰り返す。
5. 最後にできた木が**ハフマン木**となる。

#### ハフマン符号の特徴

- 各文字に割り当てられるビット列は**プレフィックス符号**（どの符号も他の符号の前半部分にならない）となるため、復号が容易。
- 最適な符号長を実現できる（情報理論的に最小の平均符号長）。

#### 例

| 文字 | 頻度 | 割り当てられる符号例 |
|------|------|----------------------|
| A    | 5    | 0                    |
| B    | 2    | 10                   |
| C    | 1    | 110                  |
| D    | 1    | 111                  |


***


XOR（排他的論理和）など、紛らわしい論理演算回路の心理地図的メモを書いてみるね。感覚的に整理できるようにしてみたよ。

***


### 1. AND（論理積）
- **イメージ**：両方が「YES（1）」ならOK
- みんなで協力して「両方が真」じゃないとダメな時に使う
- 入力が両方1のときだけ出力1、それ以外は0

***

### 2. OR（論理和）
- **イメージ**：どちらか1つでも「YES（1）」ならOK
- 「どっちかが真なら結果も真」って意味
- 少なくとも1つが1なら出力1

***

### 3. XOR（排他的論理和）
- **イメージ**：「どちらか一方だけYES（1）ならOK」だけど、両方同時はダメ
- 「違いをチェックする」スイッチみたいな感じ
- 入力が異なるときだけ出力1、同じなら0

***

### 4. NAND（否定論理積）
- **イメージ**：「ANDの逆」
- 「両方が1じゃなければOK」みたいなノリ
- ANDの結果を反転させたもの

***

### 5. NOR（否定論理和）
- **イメージ**：「ORの逆」
- どちらも0（NO）のときだけOK
- ORの結果を反転させたもの

***

### 6. XNOR（論理一致素子）
- **イメージ**：「XORの逆」
- 入力が同じだったら1（YES）を返す
- 「一致チェック装置」

***

### 7. NOT（論理否定器）
- **イメージ**：単純に「YESかNOをひっくり返す」
- 1→0、0→1

***

### 覚え方のコツ

- AND, ORは「みんなで集まるか、どちらかがOKか」
- XORは「違うかどうかを判定する関数」
- NAND, NORは、それぞれAND, ORの「裏（反転）」バージョン
- XNORはXORの「一致してるよ」の逆
- NOTは「真偽をひっくり返す」

***

# ハードウェア
## 代表的な5台装置

1. **レジスタ**
   - データを一時的に記憶する装置。
   - CPU内部で計算途中の値やアドレスなどを保持する。
   - 高速に読み書きできる。

2. **ALU（算術論理演算装置）**
   - Arithmetic Logic Unitの略。
   - 加算・減算などの算術演算や、AND・ORなどの論理演算を行う。
   - CPUの中核的な演算装置。

3. **制御装置**
   - プログラムの命令を解釈し、各装置に指示を出す。
   - 命令の取り出し、解読、実行の流れを制御する。

4. **主記憶装置（メインメモリ）**
   - プログラムやデータを一時的に保存する装置。
   - CPUが直接アクセスできる記憶領域（RAMなど）。

5. **入出力装置（I/O装置）**
   - コンピュータと外部（人や他の機器）とのデータのやり取りを行う装置。
   - 例：キーボード、ディスプレイ、プリンタ、USBメモリなど。



***

# 並列処理の分類

コンピュータの並列処理（パラレルプロセッシング）は、命令とデータの流れによって以下の4タイプに分けられるよ。

| 略称 | 名前（日本語）                | 名前（英語）                                       | 説明                                             |
|:----:|:--------------------------|:--------------------------------------------------|:------------------------------------------------|
| SISD | 単一命令・単一データ流      | Single Instruction Stream Single Data Stream      | 一般的な「順次処理」のCPU。1つの命令で1つのデータを処理。        |
| SIMD | 単一命令・複数データ流      | Single Instruction Stream Multi Data Stream       | 1つの命令で複数のデータを同時処理（画像処理やGPU等）。            |
| MISD | 複数命令・単一データ流      | Multi Instruction Stream Single Data Stream       | 複数の命令を1つのデータに適用。実際はほとんど使われない。         |
| MIMD | 複数命令・複数データ流      | Multi Instruction Stream Multi Data Stream        | 複数の命令で複数のデータを同時並行に処理（サーバ、マルチコアCPU等）。 |

***

## イメージ図（例）

- **SISD**：ふつうの1人作業
- **SIMD**：先生が同時にみんなに「同じ作業」を指示して、みんなで別のデータを処理
- **MISD**：みんなが同じデータをいろんなやり方で料理する
- **MIMD**：みんながバラバラの作業をバラバラのデータでやってる（複雑なチーム戦！）

***

### 補足
- 実際に使われているのは主にSISD、SIMD、MIMD
- SIMD：GPU（画像処理やAI計算で大活躍！）
- MIMD：サーバやデスクトップPCのマルチコアCPU

***

***

# 並列処理方式のグラフィカル解説

## SISD（Single Instruction Single Data）

```
[命令]→[CPU]→[データ1]
```
- **1つの命令**を**1つのデータ**に処理
- 普通のシングルコアPC

***

## SIMD（Single Instruction Multi Data）

```
  ↓
[命令]
  │
 ┌────────────┐
 │  [CPU]→[データ1]
 │  [CPU]→[データ2]
 └────────────┘
```
- **同じ命令**で**複数データ**を並列処理
- 画像編集やAI計算（GPU）

***

## MISD（Multi Instruction Single Data）

```
[命令1]→[CPU]→
[命令2]→[CPU]→[データ1]
```
- **複数の命令**を**1つのデータ**に対して処理
- 実際にはほとんど使われていない（特殊な計算機のみ）

***

## MIMD（Multi Instruction Multi Data）

```
  ↓           ↓
[命令1]    [命令2]
   │          │
[CPU1]→[データ1]
[CPU2]→[データ2]
```
- **複数の命令**で**複数のデータ**を並列処理
- サーバやマルチコアCPU（違うタスクを並行処理）

***

## イメージ早見メモ

|   タイプ   | 命令ストリーム | データストリーム | ざっくりイメージ           |
|:----------:|:-------------:|:---------------:|:--------------------------|
|    SISD    |      1        |       1         | 普通のシングルコア        |
|    SIMD    |      1        |      複数       | 同じ命令でみんなで処理    |
|    MISD    |     複数      |       1         | みんなで違うやり方で1個処理|
|    MIMD    |     複数      |      複数       | みんなで違う処理を同時実行 |

***

「どんなイメージ？」って聞かれたら、  
- SIMDは体育の「ラジオ体操」（全員同じ指示！）  
- MIMDは工場のライン作業みたいに、それぞれ別作業を同時進行



## GOAL
**CPUについて深く理解する**

***

## 主なトピック（TOPICS）

- 命令実行手順
- レジスタ
- アドレス指定方式
- 性能指標
    - CPI（Cycles Per Instruction）
    - MIPS（Million Instructions Per Second）
    - FLOPS（Floating Point Operations Per Second）
    - 命令ミックス
- 設計思想
    - CISC（Complex Instruction Set Computer）
    - RISC（Reduced Instruction Set Computer）
- 高速化
    - スーパースカラ
    - スーパーパイプライン

***

### 補足メモ

- **命令実行手順**：CPUが命令をどんな順番で処理するか
- **レジスタ**：CPU内部で使う高速な一時記憶領域。計算やデータ転送時に多用される
- **アドレス指定方式**：メモリ上のデータにどうアクセスするかのルール
- **性能指標**：
    - CPI：1命令ごとに何クロックかかるか
    - MIPS：1秒間に何百万命令処理できるか
    - FLOPS：浮動小数点演算の性能目安
    - 命令ミックス：どんな命令がよく使われるか
- **設計思想**：
    - CISC：命令が多機能＆複雑だけど、コードが短くて済む
    - RISC：単純な命令を高速に大量処理できる
- **高速化**：
    - スーパースカラ：複数命令を同時実行する技術
    - スーパーパイプライン：命令の細分化と並列実行で速度UP

***


***

# CPU命令実行サイクルのイメージ

## フェッチ → 解読 → オペランド読み出し → 命令実行

***

```
┌───────────────────────────────┐
│         汎用レジスタ           │          命令レジスタ
│       ┌───────────┐       ┌────────┐
│       │ データ     │←─┐    │命令    │─┬→ALU
│       │ 結果      │──┘    │プログラムカウンタ│
│                              │0006    │
└───────────────────────────────┘
   ↑                                    ↑
   │                                    │
   │                                    └───ALU（演算装置）で演算実行
   │
外部メモリ（RAMなど）

┌───────────────────────────────┐
│  0001 │ 0002 │ 0003 │ 0004 │ 0005 │ 0006 │
│  0007 │ 0008 │ 0009 │ 0010 │ 0011 │ 0012 │
└───────────────────────────────┘
```

***



1. **命令サイクル：**  
   上部の「フェッチ→解読→オペランド読み出し→命令実行」は、CPUが命令を処理するときの一連の流れだよ。

2. **レジスタ構成：**
   - 汎用レジスタ：計算するためのデータを一時的に保存。  
   - 命令レジスタ：今実行中の命令を格納。  
   - プログラムカウンタ：今どの命令を実行しているか番号で管理（例: 0006）

3. **命令とデータの流れ：**
   - 命令レジスタから命令がALU（演算装置）に送られる
   - 汎用レジスタからデータ→ALUへ。演算して結果を汎用レジスタに戻す

4. **メモリ：**
   - 下部は主記憶（メインRAMなど）のイメージ。ここから命令やデータを取り出して使う

***

## ワンポイント

- **汎用レジスタ**は作業台  
- **命令レジスタ**は指示書  
- **ALU**は計算機（Calculator）  
- **プログラムカウンタ**は実行中の命令番号を管理するカウンター

***

これがCPUの基本的な命令実行の流れ！  
「各部品の役割」や「処理順序」がイメージで掴めると思うよ。

気になる部分があればもっと詳しく解説できるから、ぜひ聞いてね！

プログラムカウンタが次の命令のメモリアドレスを指し、そこから命令を命令レジスタに取り込む。命令レジスタの内容に従い、ALUが計算を行い、データや計算結果は汎用レジスタに格納される。

## アドレス指定方式まとめ

コンピュータの命令は「命令部」と「オペランド部（データや番地）」で構成されているよ。  
オペランド部に何が入っているか、どうやってデータを指定するかによって「アドレス指定方式」が分かれるんだ！

---

### 1. 即値アドレス指定方式（イミディエイト方式）

- **特徴**：オペランド部に「生のデータ（値）」が直接入っている
- **イメージ**：「この命令で5を使ってね！」と命令の中に値が書いてある
- **例**：`MOV A, #5`（Aに5を入れる）

| 命令部 | オペランド部 |
|--------|--------------|
| 何する | 5（値そのもの）|

---

### 2. 直接アドレス指定方式

- **特徴**：オペランド部に「データが入っているメモリの番地」が書いてある
- **イメージ**：「この番地（アドレス）にあるデータを使ってね」
- **例**：`MOV A, 1000`（アドレス1000番地のデータをAに入れる）

| 命令部 | オペランド部 |
|--------|--------------|
| 何する | 1000（データが入っている番地）|

---

### 3. 間接アドレス指定方式

- **特徴**：オペランド部に「番地が書いてある番地」が入っている  
  つまり、まずオペランド部の番地に行き、そこに書いてある値を「本当の番地」として使う
- **イメージ**：「この番地に行って、そこに書いてある番地に本当のデータがあるよ」
- **例**：`MOV A, (2000)`（アドレス2000番地に書いてある値を番地として、その番地のデータをAに入れる）

| 命令部 | オペランド部 |
|--------|--------------|
| 何する | 2000（→その中身が本当の番地）|

- **ポイント**：コールバック関数みたいに「一手間かかる」けど、柔軟なデータ参照ができる！

---

### 4. インデックスアドレス指定方式

- **特徴**：オペランド部に「基準となる番地」と「インデックスレジスタ（加算値）」を組み合わせて、最終的な番地を決める方式
- **イメージ**：「配列のn番目」みたいに、基準アドレス＋インデックスでデータを順番にアクセスできる
- **例**：`MOV A, 3000(X)`（アドレス3000＋X番地のデータをAに入れる）

| 命令部 | オペランド部 |
|--------|--------------|
| 何する | 3000（基準）+ X（インデックスレジスタ）|

- **用途**：配列や連続データの処理に便利！  
  例：for文で配列を順番に処理する時など

---

### 5. ベースアドレス指定方式

- **特徴**：オペランド部に「基準となる番地（ベースアドレス）」と「ベースレジスタ」の値を加算して、最終的な番地を決める方式
- **イメージ**：「プログラムやデータのまとまり（領域）」の先頭をベースレジスタで管理し、そこからの相対位置でデータにアクセスする
- **例**：`MOV A, 0(B)`（ベースレジスタBの値＋0番地のデータをAに入れる）

| 命令部 | オペランド部 |
|--------|--------------|
| 何する | 0（オフセット）+ B（ベースレジスタ）|

- **用途**：プログラムの実行時にデータ領域やスタック領域の先頭が変わる場合など、柔軟なメモリアクセスに便利

---

### まとめ表

| 方式名                     | オペランド部の内容                 | 例（擬似命令）         | 特徴・用途                             |
|----------------------------|------------------------------------|------------------------|----------------------------------------|
| 即値アドレス指定方式       | 値そのもの                        | MOV A, #5              | 定数を使いたい時                       |
| 直接アドレス指定方式       | データの番地                      | MOV A, 1000            | 単純なメモリアクセス                   |
| 間接アドレス指定方式       | 番地が書いてある番地               | MOV A, (2000)          | 柔軟な参照、ポインタ的な使い方         |
| インデックスアドレス指定方式 | 基準番地＋インデックスレジスタ     | MOV A, 3000(X)         | 配列・連続データの処理に便利           |
| ベースアドレス指定方式     | オフセット＋ベースレジスタ         | MOV A, 0(B)            | プログラムやデータ領域の管理に便利     |

---
